import csv
import sys 

# Process the json file generated by the lncli describegraph
# Get 
def process_graph_json(csv_file):
    hops = []
    path_ids = set()
    with open(csv_file, 'r') as file:
        reader = csv.DictReader(file)
        for row in reader:
            hop = {
                'path_id': int(row['path_id']),
                'channel_name': row['channel_name'],
                'cltv_delta': int(row['cltv_delta']),
                'base_fee_msat': int(row['base_fee_msat']),
                'proportional_fee_ppm': int(row['proportional_fee_ppm'])
            }
            hops.append(hop)
            path_ids.add(hop['path_id'])    # Add path_id to the set of unique values
    return hops, len(path_ids)              # Return hops list and the number of routes > 1 if it is MPP

# Take the info needed from lightning invoice
def decode_lightning_invoice(invoice):
    try:
        decoded = bolt11.decode(invoice)
        return {
            "payment_secret": decoded.payment_secret,
            "amount_msat": decoded.amount_msat,
            "cltv_expiry": decoded.min_final_cltv_expiry
        }
    except Exception as e:
        return {"error": str(e)}
 
def main(csv_file, payment_request, block_height):
    # Load Lightning Network route from CSV file
    processed_route = process_route_csv(csv_file)
    # Separate hops by path_id
    hops_by_path_id = {}
    for hop in processed_route[0]:
        path_id = hop['path_id']
        if path_id not in hops_by_path_id:
            hops_by_path_id[path_id] = []
        hops_by_path_id[path_id].append(hop)
    # Count the number of routes, 1 for single route, n for MPP
    routes_counter = processed_route[1]
    decoded_invoice = decode_lightning_invoice(payment_request)
    # If MPP mount the TLV field
    if routes_counter > 1:
        mpp_value = int(decoded_invoice["amount_msat"]/routes_counter)
        total_value = decoded_invoice["amount_msat"]
        hex_value = hex(total_value)[2:]  # Remove '0x' prefix from hexadecimal string
        # Ensure the hexadecimal string is 16 characters long (8 bytes)
        hex_value = hex_value.zfill(16)
        TLV = TLV_TYPE+TLV_LENGHT+decoded_invoice["payment_secret"]+hex_value
    # interact trought the routes mounting the htlc by path_id
    htlc_by_path_id = {}
    for path_id, hops in hops_by_path_id.items():
        last_hop = True
        htlc_by_path_id[path_id] = []
        total_fee = 0
        # start the htlc from the end of the route to the start
        for hop in reversed(hops):
            # Last hop of one of the MPP routes
            if last_hop and routes_counter > 1:
                hop_value = mpp_value
                hop_expiry = block_height + decoded_invoice["cltv_expiry"]
                htlc_item = {
                "path_id": path_id,
                "channel_name": hop["channel_name"],
                "hop_value": hop_value,
                "hop_expiry": hop_expiry,
                "tlv": TLV
                }
                htlc_by_path_id[path_id].append(htlc_item)              
                last_hop = False
            # Last hop of one single route
            elif last_hop and routes_counter == 1:
                #0,channelname,amount,expiry,NULL
                hop_value = decoded_invoice["amount_msat"]
                hop_expiry = block_height + decoded_invoice["cltv_expiry"]
                htlc_item = {
                "path_id": path_id,
                "channel_name": hop["channel_name"],
                "hop_value": hop_value,
                "hop_expiry": hop_expiry,
                "tlv": "NULL"
                }
                htlc_by_path_id[path_id].append(htlc_item)              
                last_hop = False
            # Hops of the route
            else:
                # Calculate fees as described in bolt7
                total_fee = int(next_hop_base_fee + (hop_value * next_hop_ppm / 1000000))
                hop_value += total_fee
                hop_expiry += next_cltv_delta
                htlc_item = {
                "path_id": path_id,
                "channel_name": hop["channel_name"],
                "hop_value": hop_value,
                "hop_expiry": hop_expiry,
                "tlv": "NULL"
                }
                htlc_by_path_id[path_id].insert(0, htlc_item)
            next_cltv_delta = hop["cltv_delta"]
            next_hop_base_fee = hop["base_fee_msat"]
            next_hop_ppm = hop["proportional_fee_ppm"]
    # print to stdout the htlc 
    for path_id, htlcs in htlc_by_path_id.items():
        for htlc in htlcs:
            print(str(htlc["path_id"])+","+htlc["channel_name"]+","+str(htlc["hop_value"])+","+str(htlc["hop_expiry"])+","+htlc["tlv"])

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: python program.py <csv_file> <payment_request> <block_height>")
        sys.exit(1)
    csv_file = sys.argv[1]
    payment_request = sys.argv[2]
    block_height = int(sys.argv[3])
    main(csv_file, payment_request, block_height)

